"""
Unified bidirectional sync between local case files and Google Sheets.

This module provides intelligent synchronization:
- New local cases (not yet in sheet) get pushed to the sheet for review
- Existing cases in the sheet get their human edits/approvals pulled back to local JSON files
- Sheet is source of truth for cases that exist there; local only generates new cases

Run with: uv run python -m src.sheets.case_sync

Options:
    --dry-run       Preview without making changes
    --push-only     Only push new cases to sheet
    --pull-only     Only pull sheet changes to local
    --verbose       Show detailed output
"""

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Optional

import gspread

from src.sheets.utils import (
    load_config,
    open_spreadsheet,
    get_worksheet,
)
from src.sheets.export_to_sheets import (
    load_cases_raw,
    extract_case_row,
    get_header_row,
    get_sheet_case_ids,
    push_rows_to_sheet,
)
from src.sheets.import_from_sheets import (
    pull_sheet_changes,
    write_validation_to_sheet,
    write_status_to_sheet,
)


class CaseCategory(Enum):
    """Category of a case based on where it exists."""
    LOCAL_ONLY = "local_only"      # Exists locally but not in sheet → PUSH
    SHEET_EXISTS = "sheet_exists"  # Exists in both → PULL (sheet wins)
    SHEET_ONLY = "sheet_only"      # Exists in sheet but not locally (edge case)


@dataclass
class CaseInfo:
    """Information about a single case for sync purposes."""
    case_id: str
    category: CaseCategory
    local_file_path: Optional[str] = None
    local_data: Optional[dict] = None
    row_data: Optional[list] = None  # Prepared row for pushing to sheet


@dataclass
class SyncPlan:
    """
    Plan for synchronization actions.
    
    This is generated by compare_cases() and describes what actions
    the sync operation should take.
    """
    # Cases that need to be pushed to the sheet (local-only)
    to_push: list[CaseInfo] = field(default_factory=list)
    
    # Cases that need to be pulled from the sheet (exist in both)
    to_pull: list[CaseInfo] = field(default_factory=list)
    
    # Cases that only exist in the sheet (no local file)
    sheet_only: list[CaseInfo] = field(default_factory=list)
    
    # Cases that were skipped (e.g., no finalized data for export)
    skipped: list[str] = field(default_factory=list)
    
    @property
    def push_count(self) -> int:
        """Number of cases to push."""
        return len(self.to_push)
    
    @property
    def pull_count(self) -> int:
        """Number of cases to pull."""
        return len(self.to_pull)
    
    @property
    def total_actions(self) -> int:
        """Total number of sync actions."""
        return self.push_count + self.pull_count
    
    def summary(self) -> str:
        """Generate a human-readable summary of the plan."""
        lines = []
        lines.append(f"Push to sheet: {self.push_count} cases")
        lines.append(f"Pull from sheet: {self.pull_count} cases")
        if self.sheet_only:
            lines.append(f"Sheet-only (no local file): {len(self.sheet_only)} cases")
        if self.skipped:
            lines.append(f"Skipped (no exportable data): {len(self.skipped)} cases")
        return "\n".join(lines)


def compare_cases(
    cases_dir: str = "data/cases",
    config: Optional[dict] = None,
    spreadsheet: Optional[gspread.Spreadsheet] = None,
    worksheet: Optional[gspread.Worksheet] = None,
    verbose: bool = False,
) -> SyncPlan:
    """
    Compare local cases against Google Sheet to determine sync actions.
    
    This is the core comparison engine that categorizes cases and builds
    a plan for what needs to be pushed vs pulled.
    
    Algorithm:
    1. Fetch all case_ids from Google Sheet
    2. Load all local case files
    3. Categorize each case:
        - LOCAL_ONLY: exists locally but not in sheet → will be pushed
        - SHEET_EXISTS: exists in both → will be pulled (sheet wins)
    4. Build and return SyncPlan
    
    Args:
        cases_dir: Path to the local cases directory
        config: Optional config dict (loads from file if not provided)
        spreadsheet: Optional spreadsheet object (opens from config if not provided)
        worksheet: Optional worksheet object (gets from spreadsheet if not provided)
        verbose: If True, print detailed progress info
        
    Returns:
        SyncPlan describing what actions need to be taken
    """
    if verbose:
        print("Comparing local cases with Google Sheet...")
    
    # Load configuration if not provided
    if config is None:
        config = load_config()
    
    # Open spreadsheet and worksheet if not provided
    if spreadsheet is None:
        try:
            spreadsheet = open_spreadsheet(config)
        except gspread.exceptions.SpreadsheetNotFound:
            if verbose:
                print("  Spreadsheet not found or not accessible")
            # If no spreadsheet, all local cases are LOCAL_ONLY
            return _build_plan_all_local(cases_dir, config, verbose)
    
    if worksheet is None:
        try:
            worksheet = get_worksheet(spreadsheet, config=config)
        except gspread.exceptions.WorksheetNotFound:
            if verbose:
                print("  Worksheet not found, treating as empty sheet")
            # If no worksheet, all local cases are LOCAL_ONLY
            return _build_plan_all_local(cases_dir, config, verbose)
    
    # Step 1: Get all case IDs from the sheet
    sheet_case_ids = get_sheet_case_ids(config, spreadsheet, worksheet)
    if verbose:
        print(f"  Found {len(sheet_case_ids)} cases in sheet")
    
    # Step 2: Load all local cases
    local_cases = load_cases_raw(cases_dir)
    if verbose:
        print(f"  Found {len(local_cases)} local case files")
    
    # Build a map of case_id -> case_data for local cases
    local_case_map = {}
    for case_data in local_cases:
        case_id = case_data.get("case_id")
        if case_id:
            local_case_map[case_id] = case_data
    
    local_case_ids = set(local_case_map.keys())
    
    # Step 3: Categorize cases
    plan = SyncPlan()
    
    # Cases in local but not in sheet → LOCAL_ONLY (push)
    local_only_ids = local_case_ids - sheet_case_ids
    for case_id in local_only_ids:
        case_data = local_case_map[case_id]
        
        # Try to extract a row for this case
        row_data = extract_case_row(case_data, config)
        
        if row_data is not None:
            case_info = CaseInfo(
                case_id=case_id,
                category=CaseCategory.LOCAL_ONLY,
                local_file_path=case_data.get("_file_path"),
                local_data=case_data,
                row_data=row_data,
            )
            plan.to_push.append(case_info)
        else:
            # Case doesn't have exportable data (no finalized refinement)
            plan.skipped.append(case_id)
    
    # Cases in both → SHEET_EXISTS (pull)
    both_ids = local_case_ids & sheet_case_ids
    for case_id in both_ids:
        case_data = local_case_map[case_id]
        case_info = CaseInfo(
            case_id=case_id,
            category=CaseCategory.SHEET_EXISTS,
            local_file_path=case_data.get("_file_path"),
            local_data=case_data,
        )
        plan.to_pull.append(case_info)
    
    # Cases in sheet but not local → SHEET_ONLY (edge case, just track)
    sheet_only_ids = sheet_case_ids - local_case_ids
    for case_id in sheet_only_ids:
        case_info = CaseInfo(
            case_id=case_id,
            category=CaseCategory.SHEET_ONLY,
        )
        plan.sheet_only.append(case_info)
    
    if verbose:
        print(f"\n  Comparison results:")
        print(f"    Local-only (to push): {len(plan.to_push)}")
        print(f"    In both (to pull): {len(plan.to_pull)}")
        print(f"    Sheet-only: {len(plan.sheet_only)}")
        print(f"    Skipped (no exportable data): {len(plan.skipped)}")
    
    return plan


def _build_plan_all_local(
    cases_dir: str,
    config: dict,
    verbose: bool = False
) -> SyncPlan:
    """
    Build a plan when there's no sheet data - all local cases should be pushed.
    
    This is a helper for when the spreadsheet or worksheet doesn't exist.
    """
    local_cases = load_cases_raw(cases_dir)
    if verbose:
        print(f"  Found {len(local_cases)} local case files")
    
    plan = SyncPlan()
    
    for case_data in local_cases:
        case_id = case_data.get("case_id")
        if not case_id:
            continue
        
        row_data = extract_case_row(case_data, config)
        
        if row_data is not None:
            case_info = CaseInfo(
                case_id=case_id,
                category=CaseCategory.LOCAL_ONLY,
                local_file_path=case_data.get("_file_path"),
                local_data=case_data,
                row_data=row_data,
            )
            plan.to_push.append(case_info)
        else:
            plan.skipped.append(case_id)
    
    if verbose:
        print(f"\n  All {len(plan.to_push)} exportable cases will be pushed")
        if plan.skipped:
            print(f"    Skipped (no exportable data): {len(plan.skipped)}")
    
    return plan


def get_local_case_ids(cases_dir: str = "data/cases") -> set[str]:
    """
    Get all case IDs from local case files.
    
    This is a utility function for quick lookups without loading full case data.
    
    Args:
        cases_dir: Path to the cases directory
        
    Returns:
        Set of case IDs found in local files
    """
    local_cases = load_cases_raw(cases_dir)
    return {case.get("case_id") for case in local_cases if case.get("case_id")}


def get_comparison_summary(
    cases_dir: str = "data/cases",
    config: Optional[dict] = None,
) -> dict:
    """
    Get a quick summary of local vs sheet case counts.
    
    This is a lightweight function that returns counts without
    loading full case data or building a complete plan.
    
    Args:
        cases_dir: Path to the cases directory
        config: Optional config dict
        
    Returns:
        Dictionary with counts:
        {
            "local_count": int,
            "sheet_count": int,
            "local_only": int,
            "in_both": int,
            "sheet_only": int
        }
    """
    if config is None:
        config = load_config()
    
    # Get local case IDs
    local_ids = get_local_case_ids(cases_dir)
    
    # Get sheet case IDs
    try:
        sheet_ids = get_sheet_case_ids(config)
    except Exception:
        # If we can't access the sheet, treat as empty
        sheet_ids = set()
    
    return {
        "local_count": len(local_ids),
        "sheet_count": len(sheet_ids),
        "local_only": len(local_ids - sheet_ids),
        "in_both": len(local_ids & sheet_ids),
        "sheet_only": len(sheet_ids - local_ids),
    }


# =============================================================================
# Sync execution functions (Phase 3 will implement these)
# =============================================================================

def execute_sync(
    plan: SyncPlan,
    cases_dir: str = "data/cases",
    config: Optional[dict] = None,
    spreadsheet: Optional[gspread.Spreadsheet] = None,
    worksheet: Optional[gspread.Worksheet] = None,
    push_only: bool = False,
    pull_only: bool = False,
    dry_run: bool = False,
    verbose: bool = False,
) -> dict:
    """
    Execute the sync plan.
    
    Currently it will:
    - Execute push operations if not pull_only
    - Execute pull operations if not push_only
    
    Args:
        plan: The SyncPlan from compare_cases()
        cases_dir: Path to the cases directory
        config: Optional config dict
        spreadsheet: Optional spreadsheet object (opens from config if not provided)
        worksheet: Optional worksheet object (gets from spreadsheet if not provided)
        push_only: If True, only push new cases
        pull_only: If True, only pull sheet changes
        dry_run: If True, preview without making changes
        verbose: If True, show detailed progress
        
    Returns:
        Dictionary with results:
        {
            "pushed": int,
            "pulled": int,
            "unchanged": int,
            "errors": int
        }
    """
    if config is None:
        config = load_config()
    
    # Open spreadsheet and worksheet if not provided (needed for pull operations)
    if spreadsheet is None and not push_only and plan.to_pull:
        try:
            spreadsheet = open_spreadsheet(config)
        except gspread.exceptions.SpreadsheetNotFound:
            if verbose:
                print("  ❌ Spreadsheet not found or not accessible")
            return {"pushed": 0, "pulled": 0, "unchanged": 0, "errors": len(plan.to_pull)}
    
    if worksheet is None and spreadsheet is not None and not push_only and plan.to_pull:
        try:
            worksheet = get_worksheet(spreadsheet, config=config)
        except gspread.exceptions.WorksheetNotFound:
            if verbose:
                print("  ❌ Worksheet not found")
            return {"pushed": 0, "pulled": 0, "unchanged": 0, "errors": len(plan.to_pull)}
    
    results = {
        "pushed": 0,
        "pulled": 0,
        "unchanged": 0,
        "errors": 0,
    }
    
    # Execute push operations
    if not pull_only and plan.to_push:
        if verbose:
            print(f"\nPushing {len(plan.to_push)} cases to sheet...")
        
        if dry_run:
            if verbose:
                for case in plan.to_push:
                    print(f"  [DRY RUN] Would push: {case.case_id}")
            results["pushed"] = len(plan.to_push)
        else:
            # Collect rows to push and track case IDs for logging
            rows_to_push = []
            case_ids_to_push = []
            for case in plan.to_push:
                if case.row_data:
                    rows_to_push.append(case.row_data)
                    case_ids_to_push.append(case.case_id)
            
            if rows_to_push:
                try:
                    # Show individual cases being pushed in verbose mode
                    if verbose:
                        for case_id in case_ids_to_push:
                            print(f"  → Pushing: {case_id}")
                    
                    pushed_count = push_rows_to_sheet(
                        rows=rows_to_push,
                        config=config,
                        include_header=True,  # Add header if sheet is empty
                    )
                    results["pushed"] = pushed_count
                    if verbose:
                        print(f"  ✅ Successfully pushed {pushed_count} cases")
                except Exception as e:
                    if verbose:
                        print(f"  ❌ Error pushing cases: {e}")
                    results["errors"] += len(rows_to_push)
    
    # Execute pull operations
    if not push_only and plan.to_pull:
        if verbose:
            print(f"\nPulling {len(plan.to_pull)} cases from sheet...")
        
        pull_case_ids = {case.case_id for case in plan.to_pull}
        
        if dry_run:
            # In dry-run mode, show individual cases like push does
            if verbose:
                for case in plan.to_pull:
                    print(f"  [DRY RUN] Would pull: {case.case_id}")
            
            # Still validate to get accurate counts
            updated, unchanged, skipped, validation_results, headers, row_numbers, status_changes = pull_sheet_changes(
                case_ids=pull_case_ids,
                config=config,
                spreadsheet=spreadsheet,
                worksheet=worksheet,
                cases_dir=cases_dir,
                dry_run=True,
                force=True,
            )
            results["pulled"] = updated
            results["unchanged"] = unchanged
            results["errors"] += skipped
            
            if verbose and validation_results:
                error_results = [r for r in validation_results if r.status == 'error']
                if error_results:
                    print(f"\n  Validation errors that would block import:")
                    for result in error_results:
                        print(f"    ❌ {result.case_id}: {', '.join(result.errors)}")
        else:
            # Actually execute the pull with detailed output
            updated, unchanged, skipped, validation_results, headers, row_numbers, status_changes = pull_sheet_changes(
                case_ids=pull_case_ids,
                config=config,
                spreadsheet=spreadsheet,
                worksheet=worksheet,
                cases_dir=cases_dir,
                dry_run=False,
                force=True,  # Pull even if validation warnings
                verbose=verbose,  # Pass verbose flag for per-case output
            )
            
            results["pulled"] = updated
            results["unchanged"] = unchanged
            results["errors"] += skipped
            
            # Write validation results to sheet (so reviewers see errors/warnings)
            if worksheet is not None and validation_results and headers:
                try:
                    if verbose:
                        print("\n  Writing validation results to sheet...")
                    write_validation_to_sheet(worksheet, validation_results, headers)
                except Exception as e:
                    if verbose:
                        print(f"  ⚠️  Could not write validation to sheet: {e}")
            
            # Write status changes back to sheet
            if worksheet is not None and status_changes and row_numbers:
                try:
                    if verbose:
                        print(f"\n  Writing {len(status_changes)} status changes to sheet...")
                    write_status_to_sheet(status_changes, worksheet, row_numbers)
                except Exception as e:
                    if verbose:
                        print(f"  ⚠️  Could not write status to sheet: {e}")
            
            if verbose:
                print(f"\n  Pull summary:")
                print(f"    Updated: {updated}")
                print(f"    Unchanged: {unchanged}")
                if status_changes:
                    print(f"    Status changes written: {len(status_changes)}")
                if skipped > 0:
                    print(f"    Skipped/Errors: {skipped}")
    
    return results


def sync(
    cases_dir: str = "data/cases",
    push_only: bool = False,
    pull_only: bool = False,
    dry_run: bool = False,
    verbose: bool = False,
) -> dict:
    """
    Main sync function - compares and executes sync in one call.
    
    This is the primary entry point for sync operations.
    
    Args:
        cases_dir: Path to the cases directory
        push_only: If True, only push new cases to sheet
        pull_only: If True, only pull sheet changes to local
        dry_run: If True, preview without making changes
        verbose: If True, show detailed output
        
    Returns:
        Dictionary with results from execute_sync()
    """
    config = load_config()
    
    if verbose:
        print("=" * 60)
        print("ValueBench Sync")
        print("=" * 60)
        print()
    
    # Open spreadsheet and worksheet once at the beginning
    # These will be passed through to avoid multiple connections
    spreadsheet = None
    worksheet = None
    try:
        spreadsheet = open_spreadsheet(config)
        worksheet = get_worksheet(spreadsheet, config=config)
    except gspread.exceptions.SpreadsheetNotFound:
        if verbose:
            print("  ⚠️  Spreadsheet not found - will only push local cases")
    except gspread.exceptions.WorksheetNotFound:
        if verbose:
            print("  ⚠️  Worksheet not found - will only push local cases")
    
    # Compare cases to build plan
    plan = compare_cases(
        cases_dir=cases_dir,
        config=config,
        spreadsheet=spreadsheet,
        worksheet=worksheet,
        verbose=verbose,
    )
    
    if verbose:
        print("\n" + "-" * 60)
        print("Sync Plan:")
        print("-" * 60)
        print(plan.summary())
        print()
    
    # Check if there's anything to do
    if plan.total_actions == 0:
        if verbose:
            print("✅ Already in sync - nothing to do")
        return {
            "pushed": 0,
            "pulled": 0,
            "unchanged": 0,
            "errors": 0,
        }
    
    # Execute the plan
    results = execute_sync(
        plan=plan,
        cases_dir=cases_dir,
        config=config,
        spreadsheet=spreadsheet,
        worksheet=worksheet,
        push_only=push_only,
        pull_only=pull_only,
        dry_run=dry_run,
        verbose=verbose,
    )
    
    if verbose:
        print("\n" + "=" * 60)
        if dry_run:
            print("[DRY RUN] Would have:")
        else:
            print("Sync complete:")
        print(f"  Pushed: {results['pushed']} cases")
        print(f"  Pulled: {results['pulled']} cases")
        if results['unchanged'] > 0:
            print(f"  Unchanged: {results['unchanged']} cases")
        if results['errors'] > 0:
            print(f"  Errors: {results['errors']}")
        print("=" * 60)
    
    return results


def main():
    """CLI entry point."""
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(
        description="Sync ValueBench cases with Google Sheets",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  uv run python -m src.sheets.case_sync                # Full bidirectional sync
  uv run python -m src.sheets.case_sync --dry-run      # Preview without changes
  uv run python -m src.sheets.case_sync --push-only    # Only push new cases
  uv run python -m src.sheets.case_sync --pull-only    # Only pull sheet changes
  uv run python -m src.sheets.case_sync --verbose      # Detailed output
        """
    )
    parser.add_argument(
        "--push-only",
        action="store_true",
        help="Only push new local cases to sheet"
    )
    parser.add_argument(
        "--pull-only",
        action="store_true",
        help="Only pull sheet changes to local files"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview what would be synced without making changes"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed output"
    )
    parser.add_argument(
        "--cases-dir",
        default="data/cases",
        help="Path to the cases directory (default: data/cases)"
    )
    
    args = parser.parse_args()
    
    # Validate options
    if args.push_only and args.pull_only:
        print("❌ Cannot specify both --push-only and --pull-only")
        sys.exit(1)
    
    try:
        results = sync(
            cases_dir=args.cases_dir,
            push_only=args.push_only,
            pull_only=args.pull_only,
            dry_run=args.dry_run,
            verbose=args.verbose or args.dry_run,  # Always verbose in dry-run mode
        )
        
        # Exit code based on errors
        sys.exit(1 if results["errors"] > 0 else 0)
        
    except FileNotFoundError as e:
        print(f"❌ {e}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

